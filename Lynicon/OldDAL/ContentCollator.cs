using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Web.Routing;
using Lynicon.Utility;
using Lynicon.Repositories;
using Lynicon.Extensibility;
using Lynicon.Models;
using Lynicon.Routing;
using System.Web.Mvc;
using System.Web;
using Lynicon.Attributes;
using Newtonsoft.Json.Linq;
using Lynicon.Map;

namespace Lynicon.Collation
{
    public class ContentCollator : ICollator
    {
        /// <summary>
        /// Gets the content path from the route values
        /// </summary>
        private string ExtractContentPath(RouteValueDictionary values)
        {
            int ord;
            string path = values
                .Where(v => v.Key.StartsWith("_") && int.TryParse(v.Key.Substring(1).UpTo("-"), out ord))
                .OrderBy(v => int.Parse(v.Key.Substring(1).UpTo("-")))
                .Select(v => v.Value)
                .Join("&");
            return path;
        }

        /// <summary>
        /// Gets the select clauses from the route values
        /// </summary>
        public Dictionary<string, object> ClausesFromRoute(RouteValueDictionary values)
        {
            return new Dictionary<string,object> { { "Path = @path", ExtractContentPath(values) } };
        }

        public static Tuple<string, RouteData> GetUrlData(Type type, string path)
        {
            var urls = new UrlHelper((HttpContext.Current.Handler as MvcHandler).RequestContext);
            var rfd = RoutesFromData(type, path);
            var urlDataList = rfd.Select(rvd => new { url = urls.RouteUrl(rvd), rvd }).ToList();
            var urlData = urlDataList.FirstOrDefault(u => u.url != null);
            RouteData rd = null;
            if (urlData != null)
            {
                rd = new RouteData();
                urlData.rvd.Do(kvp => rd.Values.Add(kvp.Key, kvp.Value));
                return new Tuple<string, RouteData>(urlData.url, rd);
            }
            else
                return new Tuple<string, RouteData>(null, null);
        }

        /// <summary>
        /// Gets all possible route value dictionaries which could have been mapped to a given content record
        /// </summary>
        /// <param name="type">type of the content</param>
        /// <param name="data">content record</param>
        /// <returns>all possible route value dictionaries </returns>
        private static IEnumerable<RouteValueDictionary> RoutesFromData(Type type, string path)
        {
            Type dataRouteType = typeof(DataRoute<>).MakeGenericType(type);
            return RouteTable.Routes
                .Where(r => dataRouteType.IsAssignableFrom(r.GetType()))
                .Cast<Route>()
                .Select(r => GenerateRouteValues(r, path))
                .Where(r => r != null);
        }

        /// <summary>
        /// Generate the route values which could have been mapped by the given route to give access to the (path of the) given data record
        /// </summary>
        /// <param name="route">route in routing table</param>
        /// <param name="data">data record being tested if it could have been accessed via route</param>
        /// <returns>route values that would have mapped to the path of the data record</returns>
        private static RouteValueDictionary GenerateRouteValues(Route route, string path)
        {
            // Get all elements of path from data
            List<string> pathEls = new List<string>();
            if (!string.IsNullOrEmpty(path))
                pathEls = path.Split(new char[] { '&' }, StringSplitOptions.RemoveEmptyEntries).ToList();

            // Get all route values generated by route, with values if they are constant or null if variable
            var allowedVals = route.AllowedValues();

            RouteValueDictionary values = new RouteValueDictionary();
            foreach (var allowedVal in allowedVals)
            {
                int idx = -1;
                if (int.TryParse(allowedVal.Key.UpTo("-"), out idx)) // the route value matches a path element
                {
                    if (idx < 0 || idx >= pathEls.Count)
                        return null;
                    if (allowedVal.Value != null && pathEls[idx] != (string)allowedVal.Value)
                        return null;
                    values.Add(allowedVal.Key, pathEls[idx]);
                }
                else // this should include 'controller' and 'action'
                {
                    if (allowedVal.Value == null)
                        return null;
                    else
                        values.Add(allowedVal.Key, allowedVal.Value);
                }
            }

            if (!(values.ContainsKey("controller") && values.ContainsKey("action")))
                throw new Exception("Content mapping in routing table doesn't specify controller and action, route url = " + route.Url);

            return values;
        }

        public object Get(Type type, RouteData rd)
        {
            return GetWithRelated(ExtractContentPath(rd.Values), null, type);
        }

        public object GetNew(Type type, RouteData rd)
        {
            if (rd == null)
                return null;
            string path = ExtractContentPath(rd.Values);
            PropertyStore newRecord = GetNewRecord(type, path);
            return GetWithRelated(path, newRecord, type);
        }

        public List<object> GetList(Type type, RouteData rd)
        {
            var clauses = new Dictionary<string, object>();
            PagingSpec spec = PagingSpec.Create(rd);
            if (spec != null)
                clauses.Add("@Paging", spec);
            return GetList(type, clauses);
        }
        public List<object> GetList(Type type, Dictionary<string, object> clauses)
        {
            bool isSummaryType = typeof(Summary).IsAssignableFrom(type);
            bool isBaseContent = typeof(BaseContent).IsAssignableFrom(type);
            List<PropertyStore> pss;

            pss = Repository.Instance.Get(type, clauses).ToList();

            if (pss == null || pss.Count == 0)
                return new List<object>();

            if (isSummaryType)
                return pss.Select(ps => GetSummary(type, ps)).ToList();
            else
                return pss.Select(ps => GetContent(isBaseContent, type, ps)).ToList();
        }

        /// <summary>
        /// Gives content object stored in a content record
        /// </summary>
        /// <param name="isBaseContent">If content object is of type BaseContent - if so supplied OriginalRecord property</param>
        /// <param name="type">type of content object</param>
        /// <param name="ps">content record as property store</param>
        /// <returns>content object</returns>
        private object GetContent(bool isBaseContent, Type type, PropertyStore ps)
        {
            object content = ps.Project<ContentItem>().GetContent(type);
            //if (isBaseContent)
            //    (content as BaseContent).OriginalRecord = ps;
            return content;
        }

        /// <summary>
        /// Efficiently gets from database and collates all data referenced by property source redirects
        /// </summary>
        /// <param name="primaryPath">path of main item</param>
        /// <param name="primaryRecord">data record of main item, if already available, or else null</param>
        /// <param name="contentType">type of main content object</param>
        /// <returns>content object</returns>
        protected virtual object GetWithRelated(string primaryPath, PropertyStore primaryRecord, Type contentType)
        {
            // Establish the records to fetch and fetch them

            var rpsAttributes = contentType
                .GetCustomAttributes(typeof(RedirectPropertySourceAttribute), false)
                .Cast<RedirectPropertySourceAttribute>()
                .ToList();
            List<string> paths = new List<string>();
            if (primaryRecord == null)
                paths.Add(primaryPath);
            paths.AddRange(rpsAttributes
                    .Select(a => PathFunctions.Redirect(primaryPath, a.SourceDescriptor))
                    .Distinct());
            List<PropertyStore> records = Repository.Instance.Get(contentType, paths).ToList();

            // Update the primary record with redirected properties from referenced records

            if (primaryRecord == null)
                primaryRecord = records.FirstOrDefault(ps => ((string)ps["Path"]) == primaryPath);
            if (primaryRecord == null)
                return null;
            JObject jContent = null;
            if (rpsAttributes.Any())
            {
                jContent = JObject.Parse((string)primaryRecord["Content"]);
                foreach (var rpsAttribute in rpsAttributes)
                {
                    string refdPath = PathFunctions.Redirect(primaryPath, rpsAttribute.SourceDescriptor);
                    if (refdPath == primaryPath) // redirected to itself
                        continue;
                    PropertyStore refdRecord = records.FirstOrDefault(ps => (string)ps["Path"] == refdPath);
                    if (refdRecord != null)
                        foreach (string propertyPath in rpsAttribute.PropertyPaths)
                        {
                            var toFromPaths = GetPaths(propertyPath);
                            JObject refdObject = JObject.Parse((string)refdRecord["Content"]);
                            jContent.CopyPropertyFrom(toFromPaths[0], refdObject, toFromPaths[1]);
                        }
                }
            }

            bool isBaseContent = typeof(BaseContent).IsAssignableFrom(contentType);

            if (jContent == null)
                return GetContent(isBaseContent, contentType, primaryRecord);

            object content = jContent.ToObject(contentType);
            //if (isBaseContent)
            //    (content as BaseContent).OriginalRecord = primaryRecord;
            return content;
        }

        public void Set(RouteValueDictionary values, object data)
        {
            var ci = GetContentItem(values, data);

            JObject jContent = SetRelated(ci.Path, data);

            ci.SetContent(data);
            PropertyStore ps = new PropertyStore();
            ps.Inject(ci);
            Repository.Instance.Set(data.GetType(), ps, ci.Path);
        }

        public void Delete(RouteValueDictionary values, object data)
        {
            var ci = GetContentItem(values, data);

            ci.SetContent(data);
            PropertyStore ps = new PropertyStore();
            ps.Inject(ci);
            Repository.Instance.Delete(data.GetType(), ps, ci.Path);
        }

        private ContentItem GetContentItem(RouteValueDictionary values, object data)
        {
            string path = null;
            if (values != null)
                path = ExtractContentPath(values);
            //else if (typeof(BaseContent).IsAssignableFrom(data.GetType()))
            //    path = ((BaseContent)data).OriginalRecord["Path"] as string;

            if (path == null)
                throw new ArgumentException("Trying to set value of content type " + data.GetType().FullName + " without available path");

            ContentItem ci = new ContentItem
            {
                DataType = data.GetType().FullName,
                Path = path
            };

            return ci;
        }

        /// <summary>
        /// Decollates changes to content object which should be redirected to other records used as property sources
        /// </summary>
        /// <param name="path">path of content record</param>
        /// <param name="data">content object</param>
        /// <returns>JObject build from content object</returns>
        protected virtual JObject SetRelated(string path, object data)
        {
            // Establish the records to fetch and fetch them

            Type contentType = data.GetType();
            var rpsAttributes = contentType
                .GetCustomAttributes(typeof(RedirectPropertySourceAttribute), false)
                .Cast<RedirectPropertySourceAttribute>()
                .Where(rpsa => !rpsa.ReadOnly)
                .ToList();
            List<string> paths = rpsAttributes
                    .Select(a => PathFunctions.Redirect(path, a.SourceDescriptor))
                    .Distinct()
                    .ToList();
            List<PropertyStore> records = Repository.Instance.Get(contentType, paths).ToList();

            // Update the fetched referenced records with updated referenced properties on the content object

            JObject jObjectContent = JObject.FromObject(data);

            List<object> ids = new List<object>();
            List<PropertyStore> vals = new List<PropertyStore>();
            if (rpsAttributes.Any())
            {
                foreach (var rpsAttribute in rpsAttributes)
                {
                    string refdPath = PathFunctions.Redirect(path, rpsAttribute.SourceDescriptor);
                    if (refdPath == path) // redirected to itself
                        continue;
                    PropertyStore refdRecord = records.FirstOrDefault(ps => (string)ps["Path"] == refdPath);
                    if (refdRecord == null)
                        refdRecord = GetNewRecord(contentType, refdPath);
                    foreach (string propertyPath in rpsAttribute.PropertyPaths)
                    {
                        JObject refdObject = JObject.Parse((string)refdRecord["Content"]);
                        var toFromPaths = GetPaths(propertyPath);
                        refdObject.CopyPropertyFrom(toFromPaths[1], jObjectContent, toFromPaths[0]);
                        refdRecord["Content"] = refdObject.ToString();
                    }
                    if (!ids.Contains(refdPath))
                    {
                        ids.Add(refdPath);
                        vals.Add(refdRecord);
                    }
                }

                if (vals.Count > 0)
                    Repository.Instance.Set(contentType, vals, ids);
            }

            return jObjectContent;
        }



        protected virtual string[] GetPaths(string path)
        {
            if (path.Contains(">"))
                return path.Split('>').Select(s => s.Trim()).ToArray(); // primary path > redirect path
            else
                return new string[] { path, path };
        }

        protected virtual PropertyStore GetNewRecord(Type type, string path)
        {
            object newContent = Activator.CreateInstance(type);
            ContentItem newCI = new ContentItem
            {
                Path = path,
                DataType = type.FullName
            };
            newCI.SetContent(newContent);
            return new PropertyStore().Inject(newCI);
        }

        protected virtual object GetSummary(Type type, PropertyStore ps)
        {
            var contentItem = ps.Project<ContentItem>();
            var summary = contentItem.GetSummary(type) as Summary;
            summary.Url = ContentMap.Instance.GetUrls(contentItem).FirstOrDefault();
            summary.Type = ContentTypeHierarchy.AllContentTypes.FirstOrDefault(t => t.FullName == contentItem.DataType);
            summary.Id = contentItem.Identity.ToString();
            return summary;
        }

        public virtual Dictionary<string, string> GetAddress(object item)
        {
            if (item is ContentItem)
                return ((ContentItem)item).Path
                    .Split('&')
                    .Select((pi, idx) => new KeyValuePair<string, string>("_" + idx.ToString(), pi))
                    .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
            throw new ArgumentException("Content collator cannot get address of type " + item.GetType().FullName);
        }
    }
}
